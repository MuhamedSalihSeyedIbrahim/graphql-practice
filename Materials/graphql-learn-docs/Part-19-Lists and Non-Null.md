<h1>Schemas and Types</h1><div><p>On this page, you&apos;ll learn all you need to know about the GraphQL type system and how it describes what data can be queried. Since GraphQL can be used with any backend framework or programming language, we&apos;ll stay away from implementation-specific details and talk only about the concepts.</p><h3><a class="anchor" name="type-system"></a>Type system <a class="hash-link" href="#type-system">#</a></h3><p>If you&apos;ve seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:</p><div id="r101"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><ol><li>We start with a special &quot;root&quot; object</li><li>We select the <code>hero</code> field on that</li><li>For the object returned by <code>hero</code>, we select the <code>name</code> and <code>appearsIn</code> fields</li></ol><p>Because the shape of a GraphQL query closely matches the result, you can predict what the query will return without knowing that much about the server. But it&apos;s useful to have an exact description of the data we can ask for - what fields can we select? What kinds of objects might they return? What fields are available on those sub-objects? That&apos;s where the schema comes in.</p><p>Every GraphQL service defines a set of types which completely describe the set of possible data you can query on that service. Then, when queries come in, they are validated and executed against that schema.</p><h3><a class="anchor" name="type-language"></a>Type language <a class="hash-link" href="#type-language">#</a></h3><p>GraphQL services can be written in any language. Since we can&apos;t rely on a specific programming language syntax, like JavaScript, to talk about GraphQL schemas, we&apos;ll define our own simple language. We&apos;ll use the &quot;GraphQL schema language&quot; - it&apos;s similar to the query language, and allows us to talk about GraphQL schemas in a language-agnostic way.</p><h3><a class="anchor" name="object-types-and-fields"></a>Object types and fields <a class="hash-link" href="#object-types-and-fields">#</a></h3><p>The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service, and what fields it has. In the GraphQL schema language, we might represent it like this:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">!</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>The language is pretty readable, but let&apos;s go over it so that we can have a shared vocabulary:</p><ul><li><code>Character</code> is a <em>GraphQL Object Type</em>, meaning it&apos;s a type with some fields. Most of the types in your schema will be object types.</li><li><code>name</code> and <code>appearsIn</code> are <em>fields</em> on the <code>Character</code> type. That means that <code>name</code> and <code>appearsIn</code> are the only fields that can appear in any part of a GraphQL query that operates on the <code>Character</code> type.</li><li><code>String</code> is one of the built-in <em>scalar</em> types - these are types that resolve to a single scalar object, and can&apos;t have sub-selections in the query. We&apos;ll go over scalar types more later.</li><li><code>String!</code> means that the field is <em>non-nullable</em>, meaning that the GraphQL service promises to always give you a value when you query this field. In the type language, we&apos;ll represent those with an exclamation mark.</li><li><code>[Episode!]!</code> represents an <em>array</em> of <code>Episode</code> objects. Since it is also <em>non-nullable</em>, you can always expect an array (with zero or more items) when you query the <code>appearsIn</code> field. And since <code>Episode!</code> is also <em>non-nullable</em>, you can always expect every item of the array to be an <code>Episode</code> object.</li></ul><p>Now you know what a GraphQL object type looks like, and how to read the basics of the GraphQL type language.</p><h3><a class="anchor" name="arguments"></a>Arguments <a class="hash-link" href="#arguments">#</a></h3><p>Every field on a GraphQL object type can have zero or more arguments, for example the <code>length</code> field below:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Starship <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">length</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">unit</span><span class="punctuation">:</span> <span class="type-name">LengthUnit</span> <span class="operator">=</span> METER<span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Float</span>
<span class="punctuation">}</span></span></span></pre><p>All arguments are named. Unlike languages like JavaScript and Python where functions take a list of ordered arguments, all arguments in GraphQL are passed by name specifically. In this case, the <code>length</code> field has one defined argument, <code>unit</code>.</p><p>Arguments can be either required or optional. When an argument is optional, we can define a <em>default value</em> - if the <code>unit</code> argument is not passed, it will be set to <code>METER</code> by default.</p><h3><a class="anchor" name="the-query-and-mutation-types"></a>The Query and Mutation types <a class="hash-link" href="#the-query-and-mutation-types">#</a></h3><p>Most types in your schema will just be normal object types, but there are two types that are special within a schema:</p><pre class="prism language-graphql"><span class="schema-def"><span class="keyword">schema</span> <span class="punctuation">{</span>
  <span class="keyword">query</span><span class="punctuation">:</span> <span class="type-name">Query</span>
  <span class="keyword">mutation</span><span class="punctuation">:</span> <span class="type-name">Mutation</span>
<span class="punctuation">}</span></span></pre><p>Every GraphQL service has a <code>query</code> type and may or may not have a <code>mutation</code> type. These types are the same as a regular object type, but they are special because they define the <em>entry point</em> of every GraphQL query. So if you see a query that looks like:</p><div id="r102"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>That means that the GraphQL service needs to have a <code>Query</code> type with <code>hero</code> and <code>droid</code> fields:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Query <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">hero</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">episode</span><span class="punctuation">:</span> <span class="type-name">Episode</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Character</span>
  <span class="attr-name">droid</span><span class="argDefs"><span class="punctuation">(</span><span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="operator">!</span><span class="punctuation">)</span></span><span class="punctuation">:</span> <span class="type-name">Droid</span>
<span class="punctuation">}</span></span></span></pre><p>Mutations work in a similar way - you define fields on the <code>Mutation</code> type, and those are available as the root mutation fields you can call in your query.</p><p>It&apos;s important to remember that other than the special status of being the &quot;entry point&quot; into the schema, the <code>Query</code> and <code>Mutation</code> types are the same as any other GraphQL object type, and their fields work exactly the same way.</p><h3><a class="anchor" name="scalar-types"></a>Scalar types <a class="hash-link" href="#scalar-types">#</a></h3><p>A GraphQL object type has a name and fields, but at some point those fields have to resolve to some concrete data. That&apos;s where the scalar types come in: they represent the leaves of the query.</p><p>In the following query, the <code>name</code> and <code>appearsIn</code> fields will resolve to scalar types:</p><div id="r103"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>We know this because those fields don&apos;t have any sub-fields - they are the leaves of the query.</p><p>GraphQL comes with a set of default scalar types out of the box:</p><ul><li><code>Int</code>: A signed 32&#x2010;bit integer.</li><li><code>Float</code>: A signed double-precision floating-point value.</li><li><code>String</code>: A UTF&#x2010;8 character sequence.</li><li><code>Boolean</code>: <code>true</code> or <code>false</code>.</li><li><code>ID</code>: The ID scalar type represents a unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an <code>ID</code> signifies that it is not intended to be human&#x2010;readable.</li></ul><p>In most GraphQL service implementations, there is also a way to specify custom scalar types. For example, we could define a <code>Date</code> type:</p><pre class="prism language-graphql"><span class="keyword">scalar</span> Date</pre><p>Then it&apos;s up to our implementation to define how that type should be serialized, deserialized, and validated. For example, you could specify that the <code>Date</code> type should always be serialized into an integer timestamp, and your client should know to expect that format for any date fields.</p><h3><a class="anchor" name="enumeration-types"></a>Enumeration types <a class="hash-link" href="#enumeration-types">#</a></h3><p>Also called <em>Enums</em>, enumeration types are a special kind of scalar that is restricted to a particular set of allowed values. This allows you to:</p><ol><li>Validate that any arguments of this type are one of the allowed values</li><li>Communicate through the type system that a field will always be one of a finite set of values</li></ol><p>Here&apos;s what an enum definition might look like in the GraphQL schema language:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">enum</span> Episode <span class="fields"><span class="punctuation">{</span>
  NEWHOPE
  EMPIRE
  JEDI
<span class="punctuation">}</span></span></span></pre><p>This means that wherever we use the type <code>Episode</code> in our schema, we expect it to be exactly one of <code>NEWHOPE</code>, <code>EMPIRE</code>, or <code>JEDI</code>.</p><p>Note that GraphQL service implementations in various languages will have their own language-specific way to deal with enums. In languages that support enums as a first-class citizen, the implementation might take advantage of that; in a language like JavaScript with no enum support, these values might be internally mapped to a set of integers. However, these details don&apos;t leak out to the client, which can operate entirely in terms of the string names of the enum values.</p><h3><a class="anchor" name="lists-and-non-null"></a>Lists and Non-Null <a class="hash-link" href="#lists-and-non-null">#</a></h3><p>Object types, scalars, and enums are the only kinds of types you can define in GraphQL. But when you use the types in other parts of the schema, or in your query variable declarations, you can apply additional <em>type modifiers</em> that affect validation of those values. Let&apos;s look at an example:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>Here, we&apos;re using a <code>String</code> type and marking it as <em>Non-Null</em> by adding an exclamation mark, <code>!</code> after the type name. This means that our server always expects to return a non-null value for this field, and if it ends up getting a null value that will actually trigger a GraphQL execution error, letting the client know that something has gone wrong.</p><p>The Non-Null type modifier can also be used when defining arguments for a field, which will cause the GraphQL server to return a validation error if a null value is passed as that argument, whether in the GraphQL string or in the variables.</p><div id="r104"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>Lists work in a similar way: We can use a type modifier to mark a type as a <code>List</code>, which indicates that this field will return an array of that type. In the schema language, this is denoted by wrapping the type in square brackets, <code>[</code> and <code>]</code>. It works the same for arguments, where the validation step will expect an array for that value.</p><p>The Non-Null and List modifiers can be combined. For example, you can have a List of Non-Null Strings:</p><pre class="prism language-graphql"><span class="attr-name">myField</span><span class="punctuation">:</span> <span class="punctuation">[</span>String<span class="operator">!</span><span class="punctuation">]</span></pre><p>This means that the <em>list itself</em> can be null, but it can&apos;t have any null members. For example, in JSON:</p><pre class="prism language-js">myField<span class="punctuation">:</span> <span class="keyword">null</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&apos;a&apos;</span><span class="punctuation">,</span> <span class="string">&apos;b&apos;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&apos;a&apos;</span><span class="punctuation">,</span> <span class="keyword">null</span><span class="punctuation">,</span> <span class="string">&apos;b&apos;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// error</span></pre><p>Now, let&apos;s say we defined a Non-Null List of Strings:</p><pre class="prism language-graphql"><span class="attr-name">myField</span><span class="punctuation">:</span> <span class="punctuation">[</span>String<span class="punctuation">]</span><span class="operator">!</span></pre><p>This means that the list itself cannot be null, but it can contain null values:</p><pre class="prism language-js">myField<span class="punctuation">:</span> <span class="keyword">null</span> <span spellcheck="true" class="comment">// error</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&apos;a&apos;</span><span class="punctuation">,</span> <span class="string">&apos;b&apos;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span>
myField<span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&apos;a&apos;</span><span class="punctuation">,</span> <span class="keyword">null</span><span class="punctuation">,</span> <span class="string">&apos;b&apos;</span><span class="punctuation">]</span> <span spellcheck="true" class="comment">// valid</span></pre><p>You can arbitrarily nest any number of Non-Null and List modifiers, according to your needs.</p><h3><a class="anchor" name="interfaces"></a>Interfaces <a class="hash-link" href="#interfaces">#</a></h3><p>Like many type systems, GraphQL supports interfaces. An <em>Interface</em> is an abstract type that includes a certain set of fields that a type must include to implement the interface.</p><p>For example, you could have an interface <code>Character</code> that represents any character in the Star Wars trilogy:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">interface</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="punctuation">}</span></span></span></pre><p>This means that any type that <em>implements</em> <code>Character</code> needs to have these exact fields, with these arguments and return types.</p><p>For example, here are some types that might implement <code>Character</code>:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">type</span> Human <span class="keyword">implements</span> Character <span class="fields"><span class="punctuation">{</span>
  <span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
  <span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
  <span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
  <span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
  <span class="attr-name">starships</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Starship</span><span class="punctuation">]</span>
  <span class="attr-name">totalCredits</span><span class="punctuation">:</span> <span class="type-name">Int</span>
<span class="punctuation">}</span></span></span>

<span class="type-def"><span class="keyword">type</span> Droid <span class="keyword">implements</span> Character <span class="fields"><span class="punctuation">{</span>
<span class="attr-name">id</span><span class="punctuation">:</span> <span class="type-name">ID</span><span class="punctuation">!</span>
<span class="attr-name">name</span><span class="punctuation">:</span> <span class="type-name">String</span><span class="punctuation">!</span>
<span class="attr-name">friends</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Character</span><span class="punctuation">]</span>
<span class="attr-name">appearsIn</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="type-name">Episode</span><span class="punctuation">]</span><span class="punctuation">!</span>
<span class="attr-name">primaryFunction</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>You can see that both of these types have all of the fields from the <code>Character</code> interface, but also bring in extra fields, <code>totalCredits</code>, <code>starships</code> and <code>primaryFunction</code>, that are specific to that particular type of character.</p><p>Interfaces are useful when you want to return an object or set of objects, but those might be of several different types.</p><p>For example, note that the following query produces an error:</p><div id="r105"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>The <code>hero</code> field returns the type <code>Character</code>, which means it might be either a <code>Human</code> or a <code>Droid</code> depending on the <code>episode</code> argument. In the query above, you can only ask for fields that exist on the <code>Character</code> interface, which doesn&apos;t include <code>primaryFunction</code>.</p><p>To ask for a field on a specific object type, you need to use an inline fragment:</p><div id="r106"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>Learn more about this in the <a href="/learn/queries/#inline-fragments">inline fragments</a> section in the query guide.</p><h3><a class="anchor" name="union-types"></a>Union types <a class="hash-link" href="#union-types">#</a></h3><p>Union types are very similar to interfaces, but they don&apos;t get to specify any common fields between the types.</p><pre class="prism language-graphql"><span class="union-def"><span class="keyword">union</span> SearchResult <span class="punctuation">=</span> <span class="type-name">Human</span> <span class="punctuation">|</span> <span class="type-name">Droid</span> <span class="punctuation">|</span> <span class="type-name">Starship</span></span></pre><p>Wherever we return a <code>SearchResult</code> type in our schema, we might get a <code>Human</code>, a <code>Droid</code>, or a <code>Starship</code>. Note that members of a union type need to be concrete object types; you can&apos;t create a union type out of interfaces or other unions.</p><p>In this case, if you query a field that returns the <code>SearchResult</code> union type, you need to use a conditional fragment to be able to query any fields at all:</p><div id="r107"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="-1260504911"><div class="query-editor" data-reactid="2"></div><div class="result-window" data-reactid="3"></div></div></div><p>The <code>**typename</code> field resolves to a <code>String</code> which lets you differentiate different data types from each other on the client.</p><p>Also, in this case, since <code>Human</code> and <code>Droid</code> share a common interface (<code>Character</code>), you can query their common fields in one place rather than having to repeat the same fields across multiple types:</p><pre class="prism language-graphql"><span class="punctuation">{</span>
search<span class="punctuation">(</span><span class="attr-name">text</span><span class="punctuation">:</span> <span class="string">&quot;an&quot;</span><span class="punctuation">)</span> <span class="punctuation">{</span>
**typename
<span class="operator">...</span> <span class="keyword">on</span> Character <span class="punctuation">{</span>
name
<span class="punctuation">}</span>
<span class="operator">...</span> <span class="keyword">on</span> Human <span class="punctuation">{</span>
height
<span class="punctuation">}</span>
<span class="operator">...</span> <span class="keyword">on</span> Droid <span class="punctuation">{</span>
primaryFunction
<span class="punctuation">}</span>
<span class="operator">...</span> <span class="keyword">on</span> Starship <span class="punctuation">{</span>
name
length
<span class="punctuation">}</span>
<span class="punctuation">}</span>
<span class="punctuation">}</span></pre><p>Note that <code>name</code> is still specified on <code>Starship</code> because otherwise it wouldn&apos;t show up in the results given that <code>Starship</code> is not a <code>Character</code>!</p><h3><a class="anchor" name="input-types"></a>Input types <a class="hash-link" href="#input-types">#</a></h3><p>So far, we&apos;ve only talked about passing scalar values, like enums or strings, as arguments into a field. But you can also easily pass complex objects. This is particularly valuable in the case of mutations, where you might want to pass in a whole object to be created. In the GraphQL schema language, input types look exactly the same as regular object types, but with the keyword <code>input</code> instead of <code>type</code>:</p><pre class="prism language-graphql"><span class="type-def"><span class="keyword">input</span> ReviewInput <span class="fields"><span class="punctuation">{</span>
<span class="attr-name">stars</span><span class="punctuation">:</span> <span class="type-name">Int</span><span class="punctuation">!</span>
<span class="attr-name">commentary</span><span class="punctuation">:</span> <span class="type-name">String</span>
<span class="punctuation">}</span></span></span></pre><p>Here is how you could use the input object type in a mutation:</p><div id="r108"><div class="miniGraphiQL" data-reactroot data-reactid="1" data-react-checksum="389438257"><div class="hasVariables" data-reactid="2"><div class="query-editor" data-reactid="3"></div><div class="variable-editor" data-reactid="4"></div></div><div class="result-window" data-reactid="5"></div></div></div><p>The fields on an input object type can themselves refer to input object types, but you can&apos;t mix input and output types in your schema. Input object types also can&apos;t have arguments on their fields.</p></div>
